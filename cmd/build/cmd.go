package build

import (
	"fmt"

	"github.com/urfave/cli"
	"jrubin.io/zb/cmd"
	"jrubin.io/zb/lib/buildflags"
	"jrubin.io/zb/lib/dag"
	"jrubin.io/zb/lib/dependency"
	"jrubin.io/zb/lib/project"
)

// TODO(jrubin) build [-i] flag
// TODO(jrubin) run gogenerate
// use directed acyclic graph to build dependencies
// add standard ldflags (git commit (-dirty), build datestamp, etc.
// automatically add missing imports to vendor/
// define deps (like .pb.go) generated by go generate and in turn their deps
// (.proto)

// Cmd is the build command
var Cmd cmd.Constructor = &cc{}

type cc struct {
	*cmd.Config
	BuildFlags buildflags.BuildFlags
	Context    *project.Context
	Install    bool
}

func (cmd *cc) New(_ *cli.App, config *cmd.Config) cli.Command {
	cmd.Config = config

	return cli.Command{
		Name:      "build",
		Usage:     "build all of the executables in each of the projects",
		ArgsUsage: "[-i] [build flags] [packages]",
		Before:    cmd.setup,
		Action:    cmd.run,
		Flags: append(cmd.BuildFlags.Flags(),
			cli.BoolFlag{
				Name:        "i",
				Usage:       "install the packages that are dependencies of the target",
				Destination: &cmd.Install,
			},
		),
	}
}

func (cmd *cc) setup(c *cli.Context) error {
	cmd.Context = &project.Context{
		BuildContext:  cmd.BuildFlags.BuildContext(),
		SrcDir:        cmd.Cwd,
		Logger:        cmd.Logger,
		ExcludeVendor: false,
	}

	return nil
}

func (cmd *cc) run(c *cli.Context) error {
	projects, err := cmd.Context.Projects(c.Args()...)
	if err != nil {
		return err
	}

	// build a list of dependencies
	graph := dag.Graph{}

	// use a map to ensure dependencies aren't added twice
	nodes := map[string]dag.Node{}

	// start with the final targets, the executables
	for _, p := range projects {
		for _, pkg := range p.Packages {
			if exe := pkg.Executable(); exe != nil {
				if _, ok := nodes[exe.Path]; ok {
					continue
				}

				enode := graph.MakeNode(exe)
				nodes[exe.Path] = enode

				// TODO(jrubin) test files, other files listed in Package?
				// TODO(jrubin) get imports and their files too
				for _, file := range pkg.GoFiles {
					// TODO(jrubin) file is not absolute
					if _, ok := nodes[file]; ok {
						continue
					}

					fnode := graph.MakeNode(dependency.GoFile(file))
					nodes[file] = fnode

					graph.MakeEdge(fnode, enode)
				}
			}
		}
	}

	sorted := graph.TopologicalSort()
	for i := range sorted {
		fmt.Fprintln(c.App.Writer, *sorted[i].Value)
	}

	return nil
}
